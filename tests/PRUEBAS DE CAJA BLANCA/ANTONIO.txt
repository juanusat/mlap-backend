⬜ PRUEBAS DE CAJA BLANCA

Prueba CB-03

*Requisito
	-Módulo: Reservas
	-Tipo de requisito: Funcional
	-Código del requisito: RF19, RF33
	-Descripción del requisito: Gestionar reservas, Reservar evento
*Datos del caso de prueba
	-Código de prueba: CB-03
	-Fecha de prueba: 15/11/2025
	-Caso de prueba: Revisión de transacciones en endpoint de reservas
	-Complejidad de la prueba: Alta
	-Estado de la prueba: Terminado
	-Descripción de la prueba: Inspeccionar el código del endpoint POST /api/reservations para verificar que toda la lógica de creación de reserva y sus requisitos asociados esté correctamente envuelta en una transacción de base de datos. Esto garantiza la atomicidad de la operación (todo o nada).
	-Datos de entrada: 
		-Archivo a inspeccionar: models/reservationModel.js (método create).
		-Buscar patrones: BEGIN, COMMIT, ROLLBACK.
		-Verificar inserción en reservation y reservation_requirement dentro de la misma transacción.
	-Resultado Esperado: El código debe implementar transacciones de base de datos correctamente, utilizando BEGIN al iniciar, COMMIT al finalizar exitosamente, y ROLLBACK en caso de error. Ambas tablas (reservation y reservation_requirement) deben ser modificadas dentro de la misma transacción para garantizar consistencia de datos.
	-Requerimientos de ambiente de pruebas: 
		-Acceso al código fuente del proyecto.
		-Herramienta para lectura y análisis de archivos JavaScript.
		-Conocimiento de patrones de transacciones en PostgreSQL con node-postgres (pg).
	-Condiciones/Restricciones: 
		La prueba es de revisión de código (caja blanca), no requiere ejecución de queries.
	-Pasos de la prueba:
		1. Leer el contenido del archivo models/reservationModel.js.
		2. Localizar el método create que maneja la creación de reservas.
		3. Verificar que se obtenga un cliente de conexión mediante getClient().
		4. Verificar presencia de BEGIN para iniciar transacción.
		5. Verificar que los INSERT a reservation y reservation_requirement estén dentro del try block.
		6. Verificar presencia de COMMIT al final del try block.
		7. Verificar presencia de ROLLBACK en el catch block.
		8. Verificar que el cliente se libere con release() en el finally block.
		
*Seguimiento:
	-Veredicto: Conforme
	-Resultado obtenido: Conforme
	-Estado actual: Conforme
	-Observaciones funcionales: Establecer la documentación correspondiente

---

Prueba CB-04

*Requisito
	-Módulo: Seguridad
	-Tipo de requisito: Funcional
	-Código del requisito: RF25
	-Descripción del requisito: Inicio de Sesión
*Datos del caso de prueba
	-Código de prueba: CB-04
	-Fecha de prueba: 15/11/2025
	-Caso de prueba: Revisión de validación de User-Agent en middleware de autenticación
	-Complejidad de la prueba: Media
	-Estado de la prueba: Terminado
	-Descripción de la prueba: Inspeccionar el código del middleware de autenticación para verificar que se implemente la validación de User-Agent. El sistema debe comparar el User-Agent de la petición HTTP actual con el User-Agent almacenado en el JWT durante el login, rechazando peticiones donde no coincidan (posible robo de token).
	-Datos de entrada: 
		-Archivo a inspeccionar: middleware/authMiddleware_new.js.
		-Buscar comparación de req.headers['user-agent'] con el User-Agent del JWT payload.
		-Verificar respuesta 401 Unauthorized cuando no coincidan.
	-Resultado Esperado: El middleware debe extraer el User-Agent del JWT decodificado, compararlo con el User-Agent del header de la petición actual, y retornar status 401 con mensaje de error apropiado si no coinciden. Esto previene el uso de tokens robados desde diferentes dispositivos o navegadores.
	-Requerimientos de ambiente de pruebas: 
		-Acceso al código fuente del proyecto.
		-Herramienta para lectura y análisis de archivos JavaScript.
		-Conocimiento de estructura de JWT y middleware de Express.
	-Condiciones/Restricciones: 
		La prueba es de revisión de código (caja blanca), no requiere ejecución de peticiones HTTP.
	-Pasos de la prueba:
		1. Leer el contenido del archivo middleware/authMiddleware_new.js.
		2. Verificar que se extraiga el token del header Authorization.
		3. Verificar que se decodifique el JWT y se extraiga el payload.
		4. Buscar la extracción del User-Agent actual: req.headers['user-agent'].
		5. Buscar la extracción del User-Agent del JWT: decoded.userAgent o similar.
		6. Verificar que exista una comparación entre ambos User-Agent.
		7. Verificar que se retorne res.status(401) cuando no coincidan.
		8. Verificar que el mensaje de error sea descriptivo (ej: "Token usado desde dispositivo diferente").

*Seguimiento:
	-Veredicto: Conforme
	-Resultado obtenido: Conforme
	-Estado actual: Conforme
	-Observaciones funcionales: Establecer la documentación correspondiente 

---