⬜ PRUEBAS DE CAJA BLANCA

Prueba CB-03

*Requisito
	-Módulo: Reservas
	-Tipo de requisito: Funcional
	-Código del requisito: RF19, RF33
	-Descripción del requisito: Gestionar reservas, Reservar evento
*Datos del caso de prueba
	-Código de prueba: CB-03
	-Fecha de prueba: 15/11/2025
	-Caso de prueba: Revisión de transacciones en endpoint de reservas
	-Complejidad de la prueba: Alta
	-Estado de la prueba: Terminado
	-Descripción de la prueba: Inspeccionar el código del endpoint POST /api/reservations para verificar que toda la lógica de creación de reserva y sus requisitos asociados esté correctamente envuelta en una transacción de base de datos. Esto garantiza la atomicidad de la operación (todo o nada).
	-Datos de entrada: 
		-Archivo a inspeccionar: models/reservationModel.js (método create).
		-Buscar patrones: BEGIN, COMMIT, ROLLBACK.
		-Verificar inserción en reservation y reservation_requirement dentro de la misma transacción.
	-Resultado Esperado: El código debe implementar transacciones de base de datos correctamente, utilizando BEGIN al iniciar, COMMIT al finalizar exitosamente, y ROLLBACK en caso de error. Ambas tablas (reservation y reservation_requirement) deben ser modificadas dentro de la misma transacción para garantizar consistencia de datos.
	-Requerimientos de ambiente de pruebas: 
		-Acceso al código fuente del proyecto.
		-Herramienta para lectura y análisis de archivos JavaScript.
		-Conocimiento de patrones de transacciones en PostgreSQL con node-postgres (pg).
	-Condiciones/Restricciones: 
		La prueba es de revisión de código (caja blanca), no requiere ejecución de queries.
	-Pasos de la prueba:
		1. Leer el contenido del archivo models/reservationModel.js.
		2. Localizar el método create que maneja la creación de reservas.
		3. Verificar que se obtenga un cliente de conexión mediante getClient().
		4. Verificar presencia de BEGIN para iniciar transacción.
		5. Verificar que los INSERT a reservation y reservation_requirement estén dentro del try block.
		6. Verificar presencia de COMMIT al final del try block.
		7. Verificar presencia de ROLLBACK en el catch block.
		8. Verificar que el cliente se libere con release() en el finally block.
		
*Seguimiento:
	-Veredicto: Conforme
	-Resultado obtenido: Conforme
	-Estado actual: Conforme
	-Observaciones funcionales: Establecer la documentación correspondiente

---

Prueba CB-04

*Requisito
	-Módulo: Seguridad
	-Tipo de requisito: Funcional
	-Código del requisito: RF25
	-Descripción del requisito: Inicio de Sesión
*Datos del caso de prueba
	-Código de prueba: CB-04
	-Fecha de prueba: 15/11/2025
	-Caso de prueba: Revisión de validación de User-Agent mediante hash SHA-256 en middleware de autenticación
	-Complejidad de la prueba: Media
	-Estado de la prueba: Terminado
	-Descripción de la prueba: Inspeccionar el código del middleware de autenticación para verificar que se implemente la validación de User-Agent mediante hash SHA-256. El sistema debe comparar el hash SHA-256 del User-Agent de la petición HTTP actual con el hash almacenado en el JWT durante el login, rechazando peticiones donde no coincidan (posible robo de token). Al detectar discrepancia, debe limpiar la cookie y retornar respuesta con flags de redirección.
	-Datos de entrada: 
		-Archivo a inspeccionar: middleware/authMiddleware_new.js.
		-Buscar función hashUserAgent que use crypto.createHash('sha256').
		-Buscar extracción de req.headers['user-agent'] y su hasheo.
		-Buscar comparación de hash actual con decoded.uaHash del JWT.
		-Verificar limpieza de cookie con clearCookie() al detectar discrepancia.
		-Verificar respuesta 401 con force_logout: true y redirect: true.
	-Resultado Esperado: El middleware debe implementar función hashUserAgent usando crypto SHA-256, extraer y hashear el User-Agent actual, comparar con decoded.uaHash del JWT, y si no coinciden debe limpiar la cookie session_token y retornar status 401 con flags force_logout y redirect para que el frontend procese el cierre de sesión. Esto previene el uso de tokens robados desde diferentes dispositivos o navegadores de forma segura sin exponer el User-Agent en el token.
	-Requerimientos de ambiente de pruebas: 
		-Acceso al código fuente del proyecto.
		-Herramienta para lectura y análisis de archivos JavaScript.
		-Conocimiento de estructura de JWT, middleware de Express y módulo crypto de Node.js.
	-Condiciones/Restricciones: 
		La prueba es de revisión de código (caja blanca), no requiere ejecución de peticiones HTTP.
	-Pasos de la prueba:
		1. Leer el contenido del archivo middleware/authMiddleware_new.js.
		2. Verificar que se extraiga el token del header Authorization o cookies.
		3. Verificar que se decodifique el JWT y se extraiga el payload.
		4. Verificar existencia de función hashUserAgent con crypto.createHash('sha256').
		5. Buscar la extracción del User-Agent actual: req.headers['user-agent'].
		6. Verificar que se hashee el User-Agent actual con hashUserAgent().
		7. Buscar la extracción del hash del JWT: decoded.uaHash.
		8. Verificar que exista comparación entre el hash actual y decoded.uaHash.
		9. Verificar que se limpie la cookie con res.clearCookie('session_token') al no coincidir.
		10. Verificar que se retorne res.status(401) con force_logout: true y redirect: true.

*Seguimiento:
	-Veredicto: Conforme
	-Resultado obtenido: Conforme
	-Estado actual: Conforme
	-Observaciones funcionales: Establecer la documentación correspondiente 

---